package rapid.task

import rapid.{Fiber, Task}

/** Extension methods for Task values */
object TaskCombinators:

  extension [A](task: Task[A])
    def start(): Fiber[A] =
      new Fiber[A] {
        private lazy val result = task.sync()
        override def sync(): A = result
      }

    def attempt: Task[Either[Throwable, A]] =
      Task {
        try Right(task.sync())
        catch case t: Throwable => Left(t)
      }

    def handleError(f: Throwable => Task[A]): Task[A] =
      Task {
        try task.sync()
        catch case t: Throwable => f(t).sync()
      }

    def guarantee(finalizer: Task[Unit]): Task[A] =
      Task.defer {
        task.attempt.flatMap {
          case Right(v) => finalizer.map(_ => v)
          case Left(e)  => finalizer.flatMap(_ => Task.error(e))
        }
      }

    def flatTap[B](f: A => Task[B]): Task[A] =
      task.flatMap(a => f(a).map(_ => a))

    def flatMap[B](f: A => Task[B]): Task[B] =
      task.flatMap(f)

    def map[B](f: A => B): Task[B] =
      task.map(f)
